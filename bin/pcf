#!/usr/bin/env bash
BASEDIR=$(dirname $(dirname $0))
. "${BASEDIR}/lib/env.sh"
. "${BASEDIR}/lib/secrets.sh"
. "${BASEDIR}/lib/generate_passphrase.sh"
. "${BASEDIR}/lib/certificates.sh"

concourse_team=pcf
concourse_target=${env_id}-${concourse_team}
concourse_url=`concourse url`
pcf_concourse_user=pivotal

pcf_pipelines_remote="https://github.com/pivotal-cf/pcf-pipelines.git"
pcf_pipelines_local=${workdir}/pcf-pipelines
pcf_pipelines_version="v0.23.0"

pcf_install_pipeline="deploy-pcf"
pcf_install_pipeline_file="${workdir}/pcf-pipelines/install-pcf/gcp/pipeline.yml"
pcf_install_parameter_file="${workdir}/${env_id}-${pcf_install_pipeline}-params.yml"

pcf_upgrade_pipeline="upgrade-pcf"
pcf_upgrade_pipeline_file="${workdir}/pcf-pipelines/upgrade-tile/pipeline.yml"
pcf_upgrade_parameter_file="${workdir}/${env_id}-${pcf_upgrade_pipeline}-params.yml"

ops_dir=${BASEDIR}/pipelines/ops

pcf_service_account_name="pcf-${short_id}"
pcf_service_account="${pcf_service_account_name}@${project}.iam.gserviceaccount.com"
pcf_key_file=${key_dir}/${project}-${pcf_service_account_name}.json
pcf_dns_zone="pcf-${short_id}-zone"         # TO DO: See if I can get this from the Terraform state (or even the pipelines terraform file)

pcf_subdomain="pcf.${subdomain}"
pcf_system_domain="system.${pcf_subdomain}"
pcf_apps_domain="apps.${pcf_subdomain}"
opsman_host="manager.${pcf_subdomain}"

terraform_statefile_bucket="${env_id}-bucket"

mysql_backup_bucket=${short_id}-mysql-backups
mysql_backup_schedule="0 0/72 * * *"

team_secret_root="concourse/${concourse_team}"
deploy_secret_root="concourse/${concourse_team}/${pcf_install_pipeline}"

pre_patch() {
  local job="pcf_pre"

  cp -r ${patch_dir}/${iaas}/${job}/terraform/. ${state_dir}/terraform
  cat <<TFVARS > ${state_dir}/vars/${job}.tfvars
pcf_subdomain="${pcf_subdomain}"
TFVARS
}

infra() {
  bbl up --state-dir ${state_dir} --debug
}

post_patch() {
  local job="pcf_post"

  cp -r ${patch_dir}/${iaas}/${job}/terraform/. ${state_dir}/terraform
}

prepare_concourse() {
  safe_auth_bootstrap
  concourse_admin="admin"
  admin_password=`safe get secret/bootstrap/concourse/${concourse_admin}:value`
  fly --target ${env_id} login --team-name main --ca-cert ${ca_cert_file} --concourse-url=${concourse_url} --username=${concourse_admin} --password=${admin_password}
  fly --target ${env_id} sync

  safe set secret/bootstrap/concourse/${pcf_concourse_user} value=`generate_passphrase 4`
  pcf_concourse_password=`safe get secret/bootstrap/concourse/${pcf_concourse_user}:value`
  fly --target ${env_id} set-team --team-name ${concourse_team} --basic-auth-username=${pcf_concourse_user} --basic-auth-password=${pcf_concourse_password}
}

concourse_login() {
  safe_auth_bootstrap
  pcf_concourse_password=`safe get secret/bootstrap/concourse/pivotal:value`
  fly --target ${concourse_target} login --team-name ${concourse_team} --ca-cert ${ca_cert_file} --concourse-url=${concourse_url} --username=${pcf_concourse_user} --password=${pcf_concourse_password}
}

download () {
  # TODO: Switch to Pivnet?
  pivnet login --api-token ${PIVNET_TOKEN}
  pivnet download-product-files --product-slug pcf-automation --release-version ${pcf_pipelines_version} --download-dir ${workdir} --glob "pcf-pipelines-${pcf_pipelines_version}.tgz" --accept-eula
  tar -xzf "${workdir}/pcf-pipelines-${pcf_pipelines_version}.tgz" -C "${workdir}"
  modernize_pipeline
  adapt_pipeline
}

adapt_pipeline() {
  ops_file_args="$(find ${ops_dir}/*.yml | sort | sed 's/^/-o /' | xargs)"
  cat "${pcf_install_pipeline_file}.orig" | yaml-patch ${ops_file_args} > ${pcf_install_pipeline_file}
}

safe_auth () {
  jq --raw-output '.auth.client_token' ${key_dir}/conrad-${env_id}-token.json | safe auth token
}

get_deploy_secret () {
  local secret="${1}"

  if  [ ${secret} == "concourse" ] ; then
    safe_auth_bootstrap
    safe get secret/bootstrap/concourse/pivotal:value
    return
  fi

  safe_auth
  safe get ${deploy_secret_root}/${secret}:value
}

get_team_secret () {
  local secret="${1}"

  if  [ ${secret} == "concourse" ] ; then
    safe_auth_bootstrap
    safe get secret/bootstrap/concourse/pivotal:value
    return
  fi

  safe_auth
  safe get ${team_secret_root}/${secret}:value
}

get_credential () {
  local product=${1}
  local credential=${2}
  local field=${3}
  if [ -z "${field}" ] ; then
    field="password"
  fi
  credential=$(om -k --target https://opsman.${pcf_subdomain} --username `safe get ${team_secret_root}/opsman_admin_username:value` --password `safe get ${team_secret_root}/opsman_admin_password:value` --skip-ssl-validation credentials --product-name ${product} --credential-reference ${credential} --credential-field ${field})
  echo $credential
}

ssl_certificates () {
  echo "Creating SSL certificate for ERT..."

  common_name="${pcf_subdomain}"
  org_unit="Continuous Delivery"

  request_certificate ${common_name} ${org_unit} --domain
  echo "SSL certificate for ERT created and stored at ${ca_dir}/${common_name}.crt, private key stored at ${ca_dir}/${common_name}.key."
}

secrets () {
  safe_auth

  safe set ${team_secret_root}/gcp_service_account_key value="$(cat ${pcf_key_file})"

  # N.B. set these two on your own, No API for them
  # safe set ${deploy_secret_root}/gcp_storage_access_key value=
  # safe set ${deploy_secret_root}/gcp_storage_secret_key:
  safe set ${team_secret_root}/git_private_key value="$(cat ${HOME}/.ssh/concourse_github)"
  safe set ${team_secret_root}/pivnet_token value=${PIVNET_TOKEN}
  safe set ${team_secret_root}/opsman_admin_username value=admin
  safe gen ${team_secret_root}/opsman_admin_password value

  # store the certificates we generated
  create_certificate "${pcf_subdomain}" \
    --domain "${pcf_subdomain}" --domain ".${pcf_apps_domain}" --domain "*.login.${pcf_system_domain}" \
    --domain "*.uaa.${pcf_system_domain}" --domain "*.${pcf_system_domain}"

  safe set ${deploy_secret_root}/pcf_ert_ssl_cert value="$(cat ${ca_dir}/live/${pcf_subdomain}/cert.pem)"
  safe set ${deploy_secret_root}/pcf_ert_ssl_key value="$(cat ${ca_dir}/live/${pcf_subdomain}/privkey.pem)"

  # credhub
  primary_key_name="${env_id}-credhub-key-1"
  safe set ${deploy_secret_root}/credhub_primary_encryption_name value=${primary_key_name}
  safe set ${deploy_secret_root}/credhub_encryption_key_name1 value=${primary_key_name}
  safe gen ${deploy_secret_root}/credhub_encryption_key_secret1 value
  safe set ${deploy_secret_root}/credhub_encryption_key_name2 value="${env_id}-credhub-key-2"
  safe gen ${deploy_secret_root}/credhub_encryption_key_secret2 value
  safe set ${deploy_secret_root}/credhub_encryption_key_name3 value="${env_id}-credhub-key-2"
  safe gen ${deploy_secret_root}/credhub_encryption_key_secret3 value

  # database Master Credentials
  safe set ${deploy_secret_root}/db_master_username value=pcf-master
  safe gen ${deploy_secret_root}/db_master_password value

  # Usernames must be 16 characters or fewer
  safe set ${deploy_secret_root}/db_diego_username value=pcf-diego
  safe gen ${deploy_secret_root}/db_diego_password value
  safe set ${deploy_secret_root}/db_notifications_username value=pcf-notification
  safe gen ${deploy_secret_root}/db_notifications_password value
  safe set ${deploy_secret_root}/db_autoscale_username value=pcf-autoscale
  safe gen ${deploy_secret_root}/db_autoscale_password value
  safe set ${deploy_secret_root}/db_uaa_username value=uaa
  safe gen ${deploy_secret_root}/db_uaa_password value
  safe set ${deploy_secret_root}/db_app_usage_service_username value=pcf-app-usage
  safe gen ${deploy_secret_root}/db_app_usage_service_password value
  safe set ${deploy_secret_root}/db_ccdb_username value=pcf-ccdb
  safe gen ${deploy_secret_root}/db_ccdb_password value
  safe set ${deploy_secret_root}/db_routing_username value=pcf-routing
  safe gen ${deploy_secret_root}/db_routing_password value

  safe set ${deploy_secret_root}/db_accountdb_username value=pcf-accounts
  safe gen ${deploy_secret_root}/db_accountdb_password value
  safe set ${deploy_secret_root}/db_networkpolicyserverdb_username value=pcf-policy
  safe gen ${deploy_secret_root}/db_networkpolicyserverdb_password value
  safe set ${deploy_secret_root}/db_nfsvolumedb_username value=pcf-nfs
  safe gen ${deploy_secret_root}/db_nfsvolumedb_password value
  safe set ${deploy_secret_root}/db_silk_username value=pcf-silk
  safe gen ${deploy_secret_root}/db_silk_password value
  safe set ${deploy_secret_root}/db_locket_username value=pcf-locket
  safe gen ${deploy_secret_root}/db_locket_password value

  safe set ${deploy_secret_root}/db_credhub_username value=pcf-credhub
  safe gen ${deploy_secret_root}/db_credhub_password value
}

pipelines() {
  install_pipeline
  opsman_pipeline
  upgrade_pipeline
  buildpack_pipeline
}

install_params () {
  cat <<PARAMS > ${pcf_install_parameter_file}
pcf_ert_domain: ${pcf_subdomain} # This is the domain you will access ERT with, for example: pcf.example.com.
system_domain: ${pcf_system_domain} # e.g. system.pcf.example.com
apps_domain: ${pcf_apps_subdomain} # e.g. apps.pcf.example.com
ert_major_minor_version: ${pas_version_regex} # ERT minor version to track (e.g ^2\.0\.[0-9]+$ will track 2.0.x versions)
mysql_monitor_recipient_email: ${email}
opsman_domain_or_ip_address: ${opsman_host} #This must be your pcf_ert_domain with "opsman." as a prefix. For example, opsman.pcf.example.com
opsman_major_minor_version: ${om_version_regex} # Ops Manager minor version to track (e.g ^2\.0\.[0-9]+$ will track 2.0.x versions)
terraform_prefix: pcf-${short_id}
pivnet_token: ${pivnet_token}
PARAMS
  install_iaas_params
}

install_pipeline () {
  concourse_login
  install_params
  fly --target ${concourse_target} set-pipeline --pipeline ${pcf_install_pipeline} \
    --config ${pcf_install_pipeline_file} --load-vars-from ${params_dir}/install-pcf/${iaas}/params.yml \
    --load-vars-from ${pcf_install_parameter_file}
  fly --target ${concourse_target} unpause-pipeline --pipeline ${pcf_install_pipeline}
}


opsman_params () {
  cat <<PARAMS > ${om_upgrade_parameter_file}
  # Existing Ops Manager VM name pattern. This should uniquely filter to a running Ops Manager instance.
# eg.  myenv-OpsMan
existing_opsman_vm_name: CHANGEME
# Ops Manager Admin Credentials - set during the installation of Ops Manager
# Either opsman_client_id/opsman_client_secret or opsman_admin_username/opsman_admin_password needs to be specified
# If you are using opsman_admin_username/opsman_admin_password, edit opsman_client_id/opsman_client_secret to be an empty value.
# If you are using opsman_client_id/opsman_client_secret, edit opsman_admin_username/opsman_admin_password to be an empty value.
opsman_client_id:
opsman_client_secret:

# If install pipeline has been used then the passphrase is same as the admin password
opsman_domain_or_ip_address: ${opsman_host} #This must be your pcf_ert_domain with "opsman." as a prefix. For example, opsman.pcf.example.com

# Ops Manager Url - FQDN to access Ops Manager without protocol (will use https), ex: opsmgr.example.com
opsman_domain_or_ip_address: CHANGEME

opsman_major_minor_version: ^2\.0\.[0-9]+$ # Ops Manager minor version to track (e.g ^2\.0\.[0-9]+$ will track 2.0.x versions)

# Pivotal Net Token to download Ops Manager binaries from https://network.pivotal.io
pivnet_token: ${pivnet_token} # value must be a Pivotal Network legacy token; UAA API tokens do not work currently work

iaas_type: ${iaas}
PARAMS
  opsman_iaas_params
}

opsman_pipeline () {
  concourse_login
  upgrade_params
  fly --target ${concourse_target} set-pipeline --pipeline ${pcf_upgrade_pipeline} \
  --config ${pcf_upgrade_pipeline_file} --load-vars-from ${params_dir}/upgrade-pcf/params.yml \
  --load-vars-from ${pcf_upgrade_parameter_file}
}

upgrade_params () {
  cat <<PARAMS > ${pcf_upgrade_parameter_file}
iaas_type: ${iaas}
opsman_domain_or_ip_address: ${opsman_host} #This must be your pcf_ert_domain with "opsman." as a prefix. For example, opsman.pcf.example.com
product_slug: elastic-runtime
# The minor product version to track, as a regexp. To track 1.11.x of a product, this would be "^2\.0\.[0-9]+$", as shown below.
product_version_regex: ${pas_version_regex}
PARAMS
}

upgrade_pipeline () {
  concourse_login
  upgrade_params
  fly --target ${concourse_target} set-pipeline --pipeline ${pcf_upgrade_pipeline} \
  --config ${pcf_upgrade_pipeline_file} --load-vars-from ${params_dir}/upgrade-pcf/params.yml \
  --load-vars-from ${pcf_upgrade_parameter_file}
}

buildpack_params () {
  cat <<PARAMS > ${pcf_upgrade_parameter_file}
# Pivotal Net Token to download binaries from https://network.pivotal.io
pivnet_token: ${pivnet_token}

# Cloud Controller url and credentials - should have admin privileges
cf_api_uri: https://api.${pcf_system_domain}
cf_user: CHANGEME
cf_password: CHANGEME
PARAMS
}

buildpack_pipeline () {
  concourse_login
  upgrade_params
  fly --target ${concourse_target} set-pipeline --pipeline ${pcf_upgrade_pipeline} \
  --config ${pcf_upgrade_pipeline_file} --load-vars-from ${params_dir}/upgrade-pcf/params.yml \
  --load-vars-from ${pcf_upgrade_parameter_file}
}

trigger() {
  job="${1}"
  echo "Triggering job ${1}"
  fly --target ${concourse_target} trigger-job -j ${pcf_install_pipeline}/${job}
  fly --target ${concourse_target} watch -j ${pcf_install_pipeline}/${job}
}

hijack() {
  job="${1}"
  echo "Hijacking job ${1}"
  fly --target ${concourse_target} hijack -j ${pcf_install_pipeline}/${job}
}

bootstrap_terraform() {
  echo "Bootstrapping PCF infrastructure..."
  trigger "bootstrap-terraform-state"
}

create_infrastructure () {
  echo "Creating PCF infrastructure..."
  trigger "create-infrastructure"
}

configure_director() {
  echo "Configuring Ops Manger Director..."
  trigger "configure-director"
}

install() {
  bootstrap_terraform
  create_infrastructure
  configure_director
}

ldap () {
  ldap_url=`ldap url`
  ldap_host=`echo ${ldap_url} | cut -d: -f2 | sed -e 's#//##g'`
  ldap_cert=`cat ${key_dir}/ldap-${env_id}.crt | perl -pe 's#\n#\x5c\x5c\x6e#g'`

  safe_auth_bootstrap
  ldap_admin_password=`safe get secret/bootstrap/ldap/admin:value`
  ldap_admin_bindDN=`ldap binddn`

  domain_context=`ldap convert ${domain}`
  pcf_bindDN="pcf_${env_id},$domain_context"
  pcf_bind_password=`generate_passphrase 4`

  safe_auth
  safe set ${deploy_secret_root}/uaa_ldap_username value=${pcf_bindDN}
  safe set ${deploy_secret_root}/uaa_ldap_password value=${pcf_bind_password}

  pcf_bind_password_enc=`echo {SHA}$(echo -n ${pcf_bind_password} | openssl sha -sha256 -binary) | base64`
  LDAPTLS_REQCERT=never ldapadd -H `ldap tunnel_url` -D ${ldap_admin_bindDN} -w ${ldap_admin_password} -f <(
    cat <<LDIF
version: 1

dn: o=PCF,${domain_context}
objectClass: top
objectClass: organization
o: PCF

dn: ou=users,o=PCF,${domain_context}
objectclass: organizationalUnit
objectclass: top
description: Contains entries which describe Cloud Foundry users
ou: users

dn: ou=systems,o=PCF,${domain_context}
objectclass: organizationalUnit
objectclass: top
description: Contains entries for systems that have access to the directory
ou: systems

dn: cn=pcf_platform,ou=systems,o=PCF,${domain_context}
objectClass: person
objectClass: top
cn: pcf_platform
sn: PCF
userPassword:: ${pcf_bind_password_enc}

dn: ou=groups,o=PCF,${domain_context}
objectclass: organizationalUnit
objectclass: top
description: Contains entries which describe Cloud Foundry groups
ou: groups
LDIF
  )

  ldap_properties=$(
    jq -n \
      --arg ldap_url "${ldap_url}" \
      --arg domain_context "${domain_context}" \
      --arg pcf_bindDN ${pcf_bindDN} \
      --arg pcf_bind_password "${pcf_bind_password}" \
      --arg ldap_cert "${ldap_cert}" \
      --arg ldap_address "${ldap_host}" \
      --arg user_search_base "ou=users,o=PCF,$domain_context" \
      --arg group_search_base "ou=groups,o=PCF,$domain_context" \
      '
        {
          ".properties.uaa": {
            "value": "ldap"
          },
          ".properties.uaa.ldap.url": {
            "value": $ldap_url
          },
          ".properties.uaa.ldap.credentials": {
            "value": {
              "identity": $pcf_bindDN,
              "password": $pcf_bind_password
            }
          },
          ".properties.uaa.ldap.search_base": {
            "value": $user_search_base
          },
          ".properties.uaa.ldap.search_filter": {
            "value": "cn={0}"
          },
          ".properties.uaa.ldap.group_search_base": {
            "value": $group_search_base
          },
          ".properties.uaa.ldap.group_search_filter": {
            "value": "member={0}"
          },
          ".properties.uaa.ldap.server_ssl_cert": {
            "value": $ldap_cert
          },
          ".properties.uaa.ldap.server_ssl_cert_alias": {
            "value": $ldap_address
          },
          ".properties.uaa.ldap.mail_attribute_name": {
            "value": "mail"
          },
          ".properties.uaa.ldap.first_name_attribute": {
            "value": "givenName"
          },
          ".properties.uaa.ldap.last_name_attribute": {
            "value": "sn"
          }
        }
      '
  )

  om --target https://opsman.${pcf_subdomain} --username `safe get ${team_secret_root}/opsman_admin_username:value` \
      --password `safe get ${team_secret_root}/opsman_admin_password:value` --skip-ssl-validation \
    configure-product --product-name cf --product-properties "$ldap_properties"
}

wipe_env() {
  fly --target ${concourse_target} trigger-job -j ${pcf_install_pipeline}/wipe-env
  fly --target ${concourse_target} watch -j ${pcf_install_pipeline}/wipe-env
}


start () {
  tunnel

  for deployment in $(bosh -n -e ${short_id}-pcf deployments --json | jq --raw-output '.Tables[].Rows[].name'); do
    bosh -n  -e ${short_id}-pcf -d ${deployment} start
    bosh -n -e ${short_id}-pcf -d ${deployment} update-resurrection on
  done
}

stop () {
  tunnel

  for deployment in $(bosh -n -e ${short_id}-pcf deployments --json | jq --raw-output '.Tables[].Rows[].name'); do
    bosh -n -e ${short_id}-pcf -d ${deployment} update-resurrection off
    bosh -n -e ${short_id}-pcf -d ${deployment} stop --hard
  done
}

exec_om () {
  safe_auth > /dev/null 2>&1
  exec om --target https://opsman.${pcf_subdomain} --username `safe get ${team_secret_root}/opsman_admin_username:value` \
      --password `safe get ${team_secret_root}/opsman_admin_password:value` --skip-ssl-validation $@
}

tunnel () {
  local port=$(netstat -aln | awk '
  $6 == "LISTEN" {
    if ($4 ~ "[.:][0-9]+$") {
      split($4, a, /[:.]/);
      port = a[length(a)];
      p[port] = 1
    }
  }
  END {
    srand()
    while (i = (44000 + int(rand() * 15000))){
      if ( !p[i]) {
        print i;
        exit 0;
      };
    };
  }')

  gcloud compute scp ubuntu@pcf-${short_id}-ops-manager:/var/tempest/workspaces/default/root_ca_certificate ${key_dir}/bosh-${short_id}-ca.crt --zone ${availability_zone_1} > /dev/null 2>&1
  gcloud compute ssh ubuntu@pcf-${short_id}-ops-manager --zone ${availability_zone_1} -- -f -N -o StrictHostKeyChecking=no -o ServerAliveInterval=300 -D ${port} > /dev/null 2>&1

  local bosh_cred="$(exec_om curl --silent --path /api/v0/deployed/director/credentials/bosh_commandline_credentials | jq --raw-output .credential)"
  local bosh_vars="${bosh_cred% *} BOSH_CA_CERT=${key_dir}/bosh-${short_id}-ca.crt BOSH_ALL_PROXY=socks5://localhost:${port}"

  eval "export ${bosh_vars}"
  bosh alias-env ${short-id}-pcf > /dev/null 2>&1
  bosh log-in > /dev/null 2>&1
  echo "export ${bosh_vars} BOSH_ENVIRONMENT=${short_id}-pcf"
}

teardown() {
  wipe_env
  fly --target ${concourse_target} destroy-pipeline -p "${pcf_install_pipeline}"
}

if [ $# -gt 0 ]; then
  while [ $# -gt 0 ]; do
    case $1 in
      pre_patch )
        pre_patch
        ;;
      post_patch)
        post_patch
        ;;
      infra)
        infra
        ;;
      prepare_concourse | prepare )
        prepare_concourse
        ;;
      concourse_login | login )
        concourse_login
        ;;
      download)
        download
        ;;
      secrets )
        secrets
        ;;
      params )
        params
        ;;
      pipelines )
        pipelines
        ;;
      install_pipeline )
        install_pipeline
        ;;
      upgrade_pipeline )
        upgrade_pipeline
        ;;
      buildpack_pipeline )
        buildpack_pipeline
        ;;
      opsman_pipeline )
        opsman_pipeline
        ;;
      install )
        install
        ;;
      deploy )
        download
        pipeline
        install
        ;;
      firewall)
        firewall
        ;;
      bootstrap_terraform | bootstrap)
        bootstrap_terraform
        ;;
      create_infrastructure | infrastructure)
        create_infrastructure
        ;;
      configure_director | director | opsman)
        configure_director
        ;;
      wipe_env | wipe)
        wipe_env
        ;;
      dns)
        dns
        ;;
      ldap)
        ldap
        ;;
      safe_auth)
        safe_auth
        ;;
      get_secret | password | secret)
        get_deploy_secret "${2}"
        shift
        ;;
      team_secret)
        get_team_secret "${2}"
        shift
        ;;
      get_credential | credential)
        get_credential "${2}" "${3}" "${4}"
        shift 3
        ;;
      trigger)
        trigger "${2}"
        shift
        ;;
      hijack)
        hijack "${2}"
        shift
        ;;
      start )
        start
        ;;
      stop )
        stop
        ;;
      teardown)
        teardown
        ;;
      tunnel)
        tunnel
        ;;
      om)
        shift
        exec_om $@
        exit
        ;;
      * )
        echo "Unrecognized option: $1" 1>&2
        exit 1
        ;;
    esac
    shift
  done
  exit
fi

pre_patch
infra

prepare_concourse
concourse_login
download
secrets
params
pipelines
install
ldap

post_patch
infra
