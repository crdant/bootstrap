#!/usr/bin/env bash
BASEDIR=$(dirname $(dirname $0))
. "${BASEDIR}/lib/env.sh"
. "${BASEDIR}/lib/secrets.sh"
. "${BASEDIR}/lib/generate_passphrase.sh"

wildcard_domain="*.pks.pcf.${subdomain}"
pcf_dns_zone="pcf-${short_id}-zone"
api_load_balancer_name="pcf-${short_id}-pks-api-router"
cluster_load_balancer_name="pcf-${short_id}-pks-cluster"

export pks_cert_file=${key_dir}/pks.pcf.${subdomain}/cert.pem
export pks_key_file=${key_dir}/pks.pcf.${subdomain}/privkey.pem

pks_api_port=9021
pks_uaa_port=8443

patch() {
  local job="pks"

  cp -r ${patch_dir}/${iaas}/${job}/terraform/. ${state_dir}/terraform

  cat <<TFVARS > ${state_dir}/vars/${job}.tfvars
pks_subdomain="pks.pcf.${subdomain}"
pks_wildcard="${wildcard_domain}"
pks_api_port="${pks_api_port}"
pks_uaa_port="${pks_uaa_port}"
pks_wildcard_cert="${pks_cert_file}"
pks_wildcard_key="${pks_key_file}"
TFVARS
}

infra() {
  bbl up --state-dir ${state_dir} --debug
}

cluster() {
  name=${1}

  cluster_name=${name}-cluster
  dns_name=${name}.pks.pcf.bbl.gcp.crdant.io

  # create the cluster
  pks create-cluster ${name}-cluster --plan small --external-hostname ${dns_name}

  # and wait until it is completed
  status="in progress"
  until [ status -eq "succeeded" || status -eq "failed" ]; do
    $cluster_details="$(pks cluster neuromod-cluster --json)"
    status="$(echo $cluster_detals | jq --raw-output '.last_action_state')"
  done

  # grab info about the master...should be a data element but not available in the provider
  uuid="$(echo $cluster_details | jq --raw-output '.uuid')"
  master_instance="$(gcloud compute instances list --filter="labels.job:master AND labels.deployment:service-instance-${uuid}" --format=json)"

  # N.B. adjust for multi-master at some point
  master_name="$(echo ${master_instance} | jq --raw-output '.[].name')"
  master_zone_uri="$(echo ${master_instance} | jq --raw-output '.[].zone' | echo "${url##*/}")"
  master_zone="${master_zone_uri##*/}"

  cat > ${work_dir}/${cluster_name}.tf <<CLUSTER_TERRAFORM
resource "google_compute_address" "pks_cluster_${name}" {
  name = "${var.env_id}-pks-${cluster_name}"
}

resource "google_dns_record_set" "pks" {
  name    = "${dns_name}."
  type = "A"
  ttl  = "${var.dns_ttl}"

  managed_zone = "${data.terraform_remote_state.pcf_pipelines.google_dns_managed_zone.env_dns_zone}"

  rrdatas = [ "${google_compute_address.pks_cluster_${name}.address}" ]
}

resource "google_compute_target_pool" "pks_cluster_${name}" {
  name = "${var.env_id}-pks-cluster"
  instances = [
    "${master_zone}/${master_instance}"
  ]
}

resource "google_compute_forwarding_rule" "pks_cluster_${name}" {
  name       = "${var.env_id}-pks-${cluster_name}"
  target     = "${google_compute_target_pool.pks_cluster_${name}.self_link}"
  ip_address = "${google_compute_address.pks_cluster_${name}.self_link}"
  port_range = "8443"
}

output "pks_cluster_lb_target_pool" {
  value = "${google_compute_target_pool.pks_cluster_${name}.name}"
}
CLUSTER_TERRAFORM

  pks get-credentials ${cluster_name}
}

if [ $# -gt 0 ]; then
  while [ $# -gt 0 ]; do
    case $1 in
      patch)
        patch
        ;;
      infra)
        infra
        ;;
      cluster)
        cluster_name=${2}
        shift
        cluster ${cluster_name}
        ;;
      *)
        echo "Unrecognized option: $1" 1>&2
        exit 1
        ;;
    esac
    shift
  done
  exit
fi

security
load_balancers
dns
firewall_rules
